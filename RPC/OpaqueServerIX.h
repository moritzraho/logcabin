/* Copyright (c) 2011-2014 Stanford University
 * Copyright (c) 2015 Diego Ongaro
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR(S) DISCLAIM ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL AUTHORS BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <deque>
#include <memory>
#include <string>
#include <unordered_set>

#include "Core/CompatHash.h"
#include "RPC/MessageSocket.h"

#include "RPC/InterfaceIX.h"


#ifndef LOGCABIN_RPC_OPAQUESERVER_H
#define LOGCABIN_RPC_OPAQUESERVER_H


namespace LogCabin {

// forward declaration
namespace Core {
class Buffer;
};

// forward declaration
namespace Event {
class Loop;
};

namespace RPC {

// forward declarations
class Address;
class OpaqueServerRPC;

/**
 * An OpaqueServer listens for incoming RPCs over TCP connections.
 * OpaqueServers can be created from any thread, but they will always run on
 * the thread running the Event::Loop.
 */
class OpaqueServer {
  public:

    typedef uint64_t MessageId;

    /**
     * An interface for handling events generated by an OpaqueServer.
     * The Handler's lifetime must outlive that of the OpaqueServer.
     */
    class Handler {
      public:
        /**
         * Destructor.
         */
        virtual ~Handler() {}

        /**
         * This method is overridden by a subclass and invoked when a new RPC
         * arrives. This will be called from the Event::Loop thread, so it must
         * return quickly. It should call OpaqueServerRPC::sendReply() if and
         * when it wants to respond to the RPC request.
         */
        virtual void handleRPC(OpaqueServerRPC serverRPC) = 0;
    };

    /**
     * Constructor. This object won't actually do anything until bind() is
     * called.
     * \param handler
     *      Handles inbound RPCs.
     * \param eventLoop --- IN linux only
     *      Event::Loop that will be used to find out when the underlying
     *      socket may be read from or written to without blocking.
     * \param maxMessageLength
     *      The maximum number of bytes to allow per request/response. This
     *      exists to limit the amount of buffer space a single RPC can use.
     *      Attempting to send longer responses will PANIC; attempting to
     *      receive longer requests will disconnect the underlying socket.
     */
    OpaqueServer(Handler& handler,
                 uint32_t maxMessageLength);

    /**
     * Destructor. OpaqueServerRPC objects originating from this OpaqueServer
     * may be kept around after this destructor returns; however, they won't
     * actually send replies anymore.
     */
    ~OpaqueServer();

    // linux was bind(listenAdress)
    std::string bind();
    void set_and_wait();
    void sendMessage(ixev_ctx* ctx, MessageId messageId, Core::Buffer contents);


  private:

    class HandlerForIX : public IX::Handler {
      public:
        explicit HandlerForIX(OpaqueServer* server);
        void handleReceivedMessage(ixev_ctx* ctx,
                                   MessageId messageId,
                                   Core::Buffer message) override;
        void handleDisconnect();
        HandlerForIX(const HandlerForIX&) = delete;
        HandlerForIX& operator=(const HandlerForIX&) = delete;

      private:
        OpaqueServer* server;
    };


    /**
     * Deals with OpaqueServerRPC objects that this class creates when it
     * receives a request.
     */
    Handler& rpcHandler;


    /**
     * The maximum number of bytes to allow per request/response.
     */
    const uint32_t maxMessageLength;

    /**
     * OpaqueServerRPC keeps a std::weak_ptr back to its originating
     * ServerMessageSocket.
     */
    friend class OpaqueServerRPC;

    // OpaqueServer is non-copyable.
    OpaqueServer(const OpaqueServer&) = delete;
    OpaqueServer& operator=(const OpaqueServer&) = delete;
}; // class OpaqueServer

} // namespace LogCabin::RPC
} // namespace LogCabin

#endif /* LOGCABIN_RPC_OPAQUESERVER_H */
